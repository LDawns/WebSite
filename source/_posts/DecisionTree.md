---
title: 证明算法复杂度下界---决策树基础篇
mathjax: true
date: 2019-04-21
categories:
- 算法
tags:
- 算法
- 复杂度证明
- 决策树
---
# 几个约定
基于易用性与通用性的考虑我们约定：
1. 任一可能的输入中，不会出现等价元素
2. 算法复杂度的结果是平滑的
3. 输入规模应为$k^n$(k的取值应使得计算尽量方便)
4. $log(n!)=\Theta (nlogn)$(可以由Stiring公式证明)

# 需要用到的公式

<font size=6><center>$\mathrm{A}_{n}^m=n*(n-1)*(n-2)*......*(n-m+1)$


$\mathrm{C}_{n}^m=\frac {\mathrm{A}_{n}^m}{m!}=\frac{n!}{m!(n-m)!}$
</center>
<font size=3>

# 什么是决策树
1. 树节点，通常以`a1:a2`的形式表示，表意为`关键操作`，例如`小于`，`大于`，`等于`，`是否在N集合内部`等等
2. 分支：即关键操作给出的决定结果
3. 叶节点：算法最终输出的所有可能结果

# 利用决策树证明比较排序的下界
1. 任何基于比较的排序都可以用决策树T建模
2. 对于一个特定的算法A$\Rightarrow$一棵特定的树T
   1. 每一个特定的输入$\Rightarrow$特定树T上的一条路径
   2. W(n)即对应树的高度
3. 比较排序下界即是所有树的最小高度
4. 而一个正确的算法，其叶子节点的个数设为L，则L满足：$n!\le L\le2^h\Rightarrow h\ge logn!\in \Omega (nlogn)$
5. 则比较排序的下界即$nlogn$

# 利用决策树证明Ksorted的下界
## 题目说明：
所谓Ksorted就是将数组划分为K个，$\forall j>i$，第j个组的每个元素比第i个组的元素都大，证明它的下界是$\Omega(nlogk)$.
## 解题思路：
有了比较排序下界的证明思路，我们知道由于二叉树性质$L\le 2^h$总成立，所以问题转化为要找最少有多少个叶子节点，也就是将n个元素有序的放在k个组中有多少组合。
## 答案：
1. 任何基于比较的Ksorted都可以用决策树T建模
2. 对于一个特定的算法A$\Rightarrow$一棵特定的树T
   1. 每一个特定的输入$\Rightarrow$特定树T上的一条路径
   2. W(n)即对应树的高度
3. Ksorted下界即是所有树的最小高度
4. 而叶子节点对应于所有可能的输出组合，问题转换为n个元素有序的放在k个组中有多少组合。
   <font size=6><center>$\mathrm{C}_n^{\frac{n}{k}}*\mathrm{C}_{n-\frac{n}{k}}^{\frac{n}{k}}*...*\mathrm{C}_{\frac{n}{k}}^{\frac{n}{k}}\ge \frac{n!}{((\frac{n}{k})!)^k}$</center><font size=3>
5. 而一个正确的算法，其叶子节点的个数设为L，则L满足(用约定4)：
   
   <font size=6><center>$\frac{n!}{((\frac{n}{k})!)^k}\le L\le2^h\Rightarrow h\in \Omega (nlogk)$</center><font size=3>
6. 则Ksorted的下界即$nlogn$


# 利用决策树证明螺丝螺母问题下界
## 题目说明：
有一堆螺丝和一堆螺母，用肉眼无法辨别大小，螺丝只能靠螺母测大小，螺母亦然，请将它们一一配对
## 解题思路：
此题可以转化为螺丝的排序问题，但要注意的是，此题决策树的状态发生了改变，不再是二叉树，而是三叉树，多了一个“`=`”的`decision`
## 答案：
1. 由于将螺丝排好序后，螺母也将随之有序，所以将问题转化为螺丝排序问题
2. 使用决策树对该问题建模，定义关键操作为'对特定螺母，螺丝比他大还是小或者正好匹配？'
3. 由于三叉树的特性，我们有$L\le3^h$
4. 而输出的排列组合为n!，于是我们有$n!\le L\le 3^h\Rightarrow h\ge logn!\Rightarrow h\in \Omega(nlogn)$
5. 所以该问题下界为$nlogn$
   
